Contexts
========

PINF Contexts contain meta data about a component and are externally inferred by the *host* and *augmentation* layers
and *internally* generated by the *runtime* layer for all components in the system.

There are three types of contexts for a component:

  1) The **Codebase Contexts** which capture meta data about the component as generated by static analysis.

  2) The **Runtime Contexts** which capture meta data about the component as used in execution flows.

  3) The **Social Contexts** which capture meta data resulting from the interaction of the component with its community of users.

The term *contexts* is used as opposed to *descriptors* as the meta data is derived by dynamic vs declarative means
and because contexts relate to each other in a hierarchical fashion thus constructing a context tree where contexts
get increasingly narrow as branches are traversed into.

Among other things the context information is used by dynamic IDEs to enable intelligent application development workflows
and by bundling tools to optimize aspects for targeted distribution.


Codebase Contexts
=================

In source, PINF identifies codebase components by traversing package filesystem trees and
statically analyzing module source code. This meta data is refreshed automatically
when changes are made to the codebase and cached for future use. The latest state may or may not become part of the codebase.

LINKS:

  * https://github.com/pinf-it/pinf-it-module-insight
  * https://github.com/pinf-it/pinf-it-package-insight
  * https://github.com/pinf-it/pinf-it-program-insight
  * https://github.com/pinf-it/pinf-it-toolchain-insight


Runtime Contexts
================

At runtime, PINF identifies runtime components by using a `$pinf` *context* object that holds all meta
data needed for the component to function within an application composed of many components.

The typical lifecycle of contexts within an application looks like this:

  1) A root context is initialized based on the program and boot package descriptors as well as UNIX environment variables.
  2) The root context is passed along to functions that accept options in a `$pinf` key.
  3) Functions use the `$pinf` context to adjust themselves to and interact with the environment.
  4) Functions pass along the `$pinf` context to other functions that accept options.
  5) A function may narrow a `$pinf` context to its own module's context before
     passing it along to other functions that accept options.
  6) Contexts are garbage collected as the code generating them is garbage collected.

LINKS:

  * https://github.com/pinf/pinf-for-nodejs/blob/master/lib/context.js


Initializing
------------

Given a minimal module `<pkg>/module.js` (cwd: `<pkg>`):

  PINF.main(function main(options, callback) {    		
  	// `options.$pinf` is the root context
  	return callback(null);
	}, module);

REF: `PINF.main` boots a new program as documented in the [API](./API.md#PINF.main) reference.
REF: `options.$pinf` is the context object as documented in the [API](./API.md#options.$pinf) reference.

We can invoke the 'main' function of the module from:

### Command Line

  $ node <pkg>/module.js

Where `PINF_*` UNIX environment variables customize the `options.$pinf` context.

REF: `PINF_*` UNIX environment variables and their affect are documented in the [API](./API.md#PINF_*) reference.

### Sandbox

	// Parent sandbox.
  PINF.main(function main(options, callback) {
		// Create a child sandbox.
		options.$pinf.sandbox("<pkg>/module.js", function(sandbox) {
			// Invoke 'main' function.
			sandbox.main(options, callback);
		}, callback);
	}, module);

REF: `PINF.sandbox` creates a new execution context as documented in the [API](./API.md#PINF.sandbox) reference.


Passing
-------

All functions that can receive options **should** if at all possible pass along the
`$pinf` property to all functions called that support their own options. This way
the context will propagate with the execution flow and allow code deep down to access it.

  function foo(options, callback) {
  	// `options.$pinf`
  	bar(options, callback);
  }
  function bar(options, callback) {
  	// `options.$pinf`
  }

Codebases **should** be built in such a way that options may be inherited and passed along to all
calls that instanciate new objects in the runtime. In async code this is the only way to keep execution flow
history that spans event loop turns.


Narrowing
---------

A function may narrow the `$pinf` context to its own module's context as needed.

  PINF.main(function main(options, callback) {
    // `options.$pinf`

    module.exports.foo = function(options, callback) {
      var opts = options.$pinf.makeOptions(options);
      // narrowed `options.$pinf` to `module`
    }

  }, module);

The narrowed `options.$pinf` context object will have the original `$pinf` context as a prototype.


Social Contexts
===============

As the component interacts with its community of users much valuable data may be obtained
that can augment the *Codebase* and *Runtime* contexts to form a complete picture of the component
in all its environments.

Package registries, continuous integration, security alert, tutorial,
monitoring services among many others may be queried for data relating to the component.

The latest state may or may not become part of the codebase.

